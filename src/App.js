import React, { Component } from "react";
import { hot } from "react-hot-loader";
import Web3 from 'web3';
import "normalize.css";
import "./App.css";
import About from "./Components/Workbench/About.js";
import Accounts from "./Components/Workbench/Accounts.js";
import CompileDeployContract from "./Components/Workbench/CompileDeployContract.js";
import ExecuteContractFunction from "./Components/Workbench/ExecuteContractFunction.js";
import Events from "./Components/Workbench/Events.js";
import FilterOptionsWatch from "./Components/Workbench/FilterOptionsWatch.js";
import LockUnlock from "./Components/Workbench/LockUnlock.js";
import SendTransaction from "./Components/Workbench/SendTransaction.js";
import SetupAndVersion from "./Components/Workbench/SetupAndVersion.js";

class App extends Component {
  constructor(props) {
    super(props);
    this.state = {
      // The sample code was compiled in Remix
      // Bytecode / Interface generated by Remix was pasted here
      contract_abidefinition: '[{"constant":false,"inputs":[],"name":"getNum","outputs":[{"name":"n","type":"uint256"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"n","type":"uint256"}],"name":"setNum","outputs":[],"payable":false,"type":"function"},{"inputs":[{"name":"x","type":"uint256"}],"payable":false,"type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"caller","type":"address"},{"indexed":true,"name":"oldNum","type":"bytes32"},{"indexed":true,"name":"newNum","type":"bytes32"}],"name":"NumberSetEvent","type":"event"}]',
      contract_bytecode: '0x6060604052341561000c57fe5b604051602080610168833981016040528080519060200190919050505b806000819055505b505b610126806100426000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806367e0badb146044578063cd16ecbf146067575bfe5b3415604b57fe5b60516084565b6040518082815260200191505060405180910390f35b3415606e57fe5b60826004808035906020019091905050608f565b005b600060005490505b90565b60006000549050816000819055506000546001026000191681600102600019163373ffffffffffffffffffffffffffffffffffffffff167f108fd0bf2253f6baf35f111ba80fb5369c2e004b88e36ac8486fcee0c87e61ce60405180905060405180910390a45b50505600a165627a7a72305820b86215323334042910c2707668d7cc3c3ec760d2f5962724042482293eba5f6b0029',
      connectedToEthereum: undefined,
      // Holds the accounts
      accounts: [],

      // Holds the filter objects
      filterWatch: undefined,
      filterEventCounter: undefined,

      // Holds the contract event object
      contractEvent: undefined,
      contractEventCounter: undefined,


      // Maintains the info on node type
      nodeType: undefined,

      // If autoRetrieveFlag is true, it will: auto connect, get accounts, set UI components, get balances
      autoRetrieveFlag: true

    }


    this.startApp = this.startApp.bind(this);    
    this.doConnect = this.doConnect.bind(this);
    this.doFilterStopWatching = this.doFilterStopWatching.bind(this);
    this.doContractEventWatchStop = this.doContractEventWatchStop.bind(this);
    this.doGetAccounts = this.doGetAccounts.bind(this);
    this.doGetBalance = this.doGetBalance.bind(this);
    this.getAccountsandBalances = this.getAccountsandBalances.bind(this);


    this.setData = this.setData.bind(this);


  }

  componentWillMount() {
    console.log("componentWillMount");
      // Checking if Web3 has been injected by the browser (Mist/MetaMask)
    if (typeof web3 !== 'undefined') {
      // Use Mist/MetaMask's provider
      window.web3 = new Web3(web3.currentProvider);
    } else {
      console.log('Injected web3 Not Found!!!')
      // fallback - use your fallback strategy (local node / hosted node + in-dapp id mgmt / fail)
      window.web3 = new Web3(new Web3.providers.HttpProvider('http://localhost:8545'));
      // var provider = document.getElementById('provider_url');
      // window.web3 = new Web3(new Web3.providers.HttpProvider(provider));
    }

    // Now you can start your app & access web3 freely:
    this.startApp();
  }

  startApp() {
    console.log('this.state.autoRetrieveFlag', this.state.autoRetrieveFlag);
    // If the app is reconnected we should reset the watch
    this.doFilterStopWatching();
    this.doContractEventWatchStop();

    // Set the connect status on the app
    if (web3 && web3.isConnected()) {
      this.setState({ connectedToEthereum: true });
      // Gets the version data and populates the result UI
      this.setWeb3Version();

      // no action to be taken if this flag is OFF  
      // during development for convinience you may set autoRetrieveFlag=true
      if(this.state.autoRetrieveFlag) {
        this.doGetAccounts();
        this.doGetNodeStatus();
        this.getMiningStatus();
        this.getSyncingStatus();
      }
    } else {
        this.setState({ connectedToEthereum: false });
        return;
    }

    // Compilation is available only for TestRPC
    // Geth 1.6 and above does not support compilation
    // MetaMask does not support compilation
    // doGetCompilers();
  }

  

  /**
 * This method is called for connecting to the node
 * The Provider URL is provided in a Document element with the 
 * id = provider_url
 */
   doConnect(providerURL) {
    // Get the provider URL
    console.log("called doConnect");
    window.web3 = new Web3(new Web3.providers.HttpProvider(providerURL));
    this.startApp();
  }

  

  doFilterStopWatching() {
    console.log("called doFilterStopWatching");
  }

  doContractEventWatchStop() {
    console.log("called doContractEventWatchStop");
  }

  doGetAccounts() {
    console.log("called doGetAccounts");
    const that = this;
    // This is the synch call for getting the accounts
    var accounts = web3.eth.accounts;
    console.log('sync accounts', accounts);
  
    // Asynchronous call to get the accounts
    // result = [Array of accounts]
    // MetaMask returns 1 account in the array - that is the currently selected account
    web3.eth.getAccounts(function (error, result) {
      if (error) {
          console.log('accounts_count', error, true);
      } else {
        accounts = result;
        console.log('accounts_count', result.length, false);
        // You need to have at least 1 account to proceed
        if(result.length == 0) {
          if(that.state.nodeType.toLowerCase().includes('metamask')){
              alert('Unlock MetaMask *and* click \'Get Accounts\'');
          }
          return;
        }



        // This populates the SELECT boxes with the accounts
        that.getAccountsandBalances(accounts);
        
        // var coinbase = web3.eth.coinbase;
        // trim it so as to fit in the window/UI
        // if(coinbase) coinbase = coinbase.substring(0,25)+'...'
        // setData('coinbase', coinbase, false);
        // set the default accounts
        var defaultAccount = web3.eth.defaultAccount;
        if(!defaultAccount){
          web3.eth.defaultAccount =  result[0];
          defaultAccount = '[Undef]' + result[0];
        }

        defaultAccount = defaultAccount.substring(0,25)+'...';
        console.log('defaultAccount', defaultAccount, false);
      }
        
    });
  }

  doGetBalance(account) {
    const that = this;
    return new Promise(function(resolve, reject){
        let balance = web3.eth.getBalance(account,web3.eth.defaultBlock, function(error, result){
            if (error) {
                reject('error');
            } else {
                let balance = web3.fromWei(result,'ether').toFixed(4);
                resolve(balance);
            }
        })
    })
    .then(function(result) {
        console.log('balance', result);
        let accountDetails = [account, result];
        // that.setState({ accounts: [...that.state.accounts, accountDetails] })
        return (accountDetails);
    })
    .catch(function(error) {
        console.log('error: ', error);
    }) 
  }

  getAccountsandBalances(accounts) {
    const that = this;
    let account;
    // for(let i=0; i<accounts.length; i++) {
    //   account = accounts[i];      
    //   this.doGetBalance(account);
    // }


    let balancePromises = accounts.map(account => this.doGetBalance(account));

    Promise.all(balancePromises)
      .then(responses => {
        // all responses are ready, we can show HTTP status codes
        // for(let response of responses) {
        //   alert(`${response.url}: ${response.status}`); // shows 200 for every url
        // }
        console.log('promise all responses: ', responses);
        that.setState({ accounts: [...that.state.accounts, responses] })
        // return responses;
      })
      // map array of responses into array of response.json() to read their content
      // .then(responses => Promise.all(responses.map(r => r.json())))
      // all JSON answers are parsed: "users" is the array of them
      // .then(responses => responses.forEach(account => alert(account)));
      }

  // getBalancePromised = account => new Promise((resolve, reject) => {
  //   web3.eth.getBalance(account, web3.eth.defaultBlock, (error, result) => {
  //     if(err){
  //       return reject(error);
  //     }
  //     const balance = web3.fromWei(result, 'ether').toFixed(4);
  //     resolve(balance);
  //   })
  // });

  // async getAccountsandBalances(accounts) {  
  //   for(const account of accounts) {
  //     const balance = await getBalancePromised(account);
      
  //     console.log(`You account is ${account} and balance is ${balance}`);
      
  //     //here do anythin you want with account and balance
  //   }
  // }


  setData(docElement, html, errored) {
    console.log(docElement, html, "error:" + errored); 
  }

  render() {
    return (
      <article>
        <About />
        <SetupAndVersion state={this.state} reConnect={this.doConnect} getNodeStatus={this.doGetNodeStatus} />
        <Accounts getAccounts={this.getAccountsandBalances} accounts={this.state.accounts}/>
        <LockUnlock />
        <SendTransaction />
        <CompileDeployContract />
        <ExecuteContractFunction />
        <FilterOptionsWatch />
        <Events />
    </article>
    );
  }
}

export default hot(module)(App);
