/**
 * web3JS Sample DAPP by http://acloudfan.com
 * Version: 102     May 20th, 2017
 * 
 * Application developed as part of the course on Ethereum Blockchain
 * All Rights Reserved - Please do not share. 
 * Updated versions of the code is available on the link below:
 * APP will be updated time to time so please check back
 * 
 * http://www.acloudfan.com
 * 
 * This DAPP is available on the following link .... to use it you would need MetaMask
 * http://TheDapps.com
 * 
 * Geth
 * =====
 * Application developed against Geth/ROPSTEN
 * 
 * TestRPC
 * =======
 * Some API NOT Supported in TestRPC
 * Etherscan.io links will not be supported for TestRPC
 * 
 * META MASK
 * =========
 * MetaMask will work - except some for some functions coded SYNCHRONOUSLY
 * You may change it to work with MetaMask
 * 
 */


// The sample code was compiled in Remix
// Bytecode / Interface generated by Remix was pasted here
var contract_abidefinition = '[{"constant":false,"inputs":[],"name":"getNum","outputs":[{"name":"n","type":"uint256"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"n","type":"uint256"}],"name":"setNum","outputs":[],"payable":false,"type":"function"},{"inputs":[{"name":"x","type":"uint256"}],"payable":false,"type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"caller","type":"address"},{"indexed":true,"name":"oldNum","type":"bytes32"},{"indexed":true,"name":"newNum","type":"bytes32"}],"name":"NumberSetEvent","type":"event"}]';
var contract_bytecode = '0x6060604052341561000c57fe5b604051602080610168833981016040528080519060200190919050505b806000819055505b505b610126806100426000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806367e0badb146044578063cd16ecbf146067575bfe5b3415604b57fe5b60516084565b6040518082815260200191505060405180910390f35b3415606e57fe5b60826004808035906020019091905050608f565b005b600060005490505b90565b60006000549050816000819055506000546001026000191681600102600019163373ffffffffffffffffffffffffffffffffffffffff167f108fd0bf2253f6baf35f111ba80fb5369c2e004b88e36ac8486fcee0c87e61ce60405180905060405180910390a45b50505600a165627a7a72305820b86215323334042910c2707668d7cc3c3ec760d2f5962724042482293eba5f6b0029';

// If autoRetrieveFlag is true, it will: auto connect, get accounts, set UI components, get balances
var autoRetrieveFlag = true;

// Holds the accounts
var accounts;

// Holds the filter objects
var filterWatch;
var filterEventCounter;

// Holds the contract event object
var contractEvent;
var contractEventCounter=0;

// Maintains the info on node type
var     nodeType = 'geth';

/**
 * Listener for load
 */
window.addEventListener('load', function() {

  // Checking if Web3 has been injected by the browser (Mist/MetaMask)
  if (typeof web3 !== 'undefined') {
    // Use Mist/MetaMask's provider
    window.web3 = new Web3(web3.currentProvider);
  } else {
    console.log('Injected web3 Not Found!!!')
    // fallback - use your fallback strategy (local node / hosted node + in-dapp id mgmt / fail)
    window.web3 = new Web3(new Web3.providers.HttpProvider('http://localhost:8545'));

    var provider = document.getElementById('provider_url').value;
    window.web3 = new Web3(new Web3.providers.HttpProvider(provider));
  }

  // Now you can start your app & access web3 freely:
  startApp()

})


/**
 * This method gets invoked when document is ready
 */
function    startApp(){

    // If the app is reconnected we should reset the watch
    doFilterStopWatching();
    doContractEventWatchStop();

    // Set the connect status on the app
    if (web3 && web3.isConnected()) {
        setData('connect_status','Connected', false);

        // Gets the version data and populates the result UI
        setWeb3Version();

        if(autoRetrieveFlag) doGetAccounts();

    } else {
        setData('connect_status','Not Connected', true);
    }

    // no action to be taken if this flag is OFF  
    // during development for convinience you may set autoRetrieveFlag=true
    if(!autoRetrieveFlag)  return;



    // doConnect();
    // // doGetAccounts();
    doGetNodeStatus();

    // Compilation is available only for TestRPC
    // Geth 1.6 and above does not support compilation
    // MetaMask does not support compilation
    doGetCompilers();
}

/**
 * This method is called for connecting to the node
 * The Provider URL is provided in a Document element with the 
 * id = provider_url
 */


function doConnect()    {

    // Get the provider URL
    var provider = document.getElementById('provider_url').value;
    var provider = document.getElementById('provider_url').value;
    window.web3 = new Web3(new Web3.providers.HttpProvider(provider));
    startApp();

}

/**
 * Get the version information for Web3
 */

function    setWeb3Version() {

    var versionJson = {};

    // Asynchronous version
    web3.version.getNode(function(error, result){
        if(error) setData('version_information',error,true);
        else {
            setData('version_information',result,false);

            if(result.toLowerCase().includes('metamask')){
                nodeType = 'metamask';
            } else if(result.toLowerCase().includes('testrpc')){
                nodeType = 'testrpc';
            } else {
                nodeType = 'geth';
            }

            
            // set up UI elements based on the node type
            setUIBasedOnNodeType();
        }
    });
}



/**
 * Uses the web3.net status to check if the client is listening and peer count
 */

function    doGetNodeStatus()  {

    // Asynch version
    web3.net.getListening(function(error, result){
        if(error) setData('get_peer_count',error,true);
        else {
            // Since connected lets get the count
            web3.net.getPeerCount(  function(  error,  result ) {
            if(error){
                setData('get_peer_count',error,true);
            } else {
                setData('get_peer_count','Peer Count: '+result,(result == 0));
            }
        });
        }
    });
}

/**
 * Gets the accounts under the node
 * 
 */

function    doGetAccounts() {
    // This is the synch call for getting the accounts
    // var accounts = web3.eth.accounts
    
    // Asynchronous call to get the accounts
    // result = [Array of accounts]
    // MetaMask returns 1 account in the array - that is the currently selected account
    web3.eth.getAccounts(function (error, result) {
        if (error) {
            setData('accounts_count', error, true);
        } else {
            accounts = result;
            setData('accounts_count', result.length, false);
            // You need to have at least 1 account to proceed
            if(result.length == 0) {
                if(nodeType == 'metamask'){
                    alert('Unlock MetaMask *and* click \'Get Accounts\'');
                }
                return;
            }

            // Remove the list items that may already be there
            removeAllChildItems('accounts_list');
            // Add the accounts as list items
            var select = document.getElementById('select_to_unlock_account');
            for (var i = 0; i < result.length; i++) {
                var opt = document.createElement('option');
                opt.value = result[i];
                opt.innerHTML = result[i];
                select.appendChild(opt)
                addAccountsToList('accounts_list',i,result[i])
            }
            
            // var coinbase = web3.eth.coinbase;
            // // trim it so as to fit in the window/UI
            // if(coinbase) coinbase = coinbase.substring(0,25)+'...'
            // setData('coinbase', coinbase, false);
            // set the default accounts
            var defaultAccount = web3.eth.defaultAccount;
            if(!defaultAccount){
                web3.eth.defaultAccount =  result[0];
                defaultAccount = '[Undef]' + result[0];
            }

            defaultAccount = defaultAccount.substring(0,25)+'...';
            setData('defaultAccount', defaultAccount, false);
        }
        // Get the balances of all accounts doGetBalances
        doGetBalances(accounts)

        // This populates the SELECT boxes with the accounts
        addAccountsToSelects(accounts);
    });
}

/**
 * Get the balances of all accounts.
 */
function    doGetBalances(accounts) {

    // Remove the balances if they already exist
    removeAllChildItems('account_balances_list');
    
    // Add the balances as the list items
    for (var i = 0; i < accounts.length; i++) {

       // var bal = web3.eth.getBalance(accounts[i]);
       web3.eth.getBalance(accounts[i],web3.eth.defaultBlock,function(error,result){
           // Convert the balance to ethers
            var bal = web3.fromWei(result,'ether').toFixed(2);
            addAccountBalancesToList('account_balances_list',i,bal);
        });
    }
}

/**
 * This gets invoked for sending the transaction
 */

function    doSendTransaction()  {

    var transactionObject = createTransactionObjectJson();

    web3.eth.sendTransaction(transactionObject, function(error, result) {

        if(error){
            setData('send_transaction_error_or_result', error, true);
        } else {
            setData('send_transaction_error_or_result', result, false);
            // set the link to ether scan
            var etherscanLinkA=document.getElementById('etherscan_io_tx_link');
            etherscanLinkA.href = createEtherscanIoUrl('tx',result);
            etherscanLinkA.innerHTML='etherscan.io'
            //console.log(etherscanLinkA)
        }
    });
}

/**
 * Unlocks the account
 * UNLOCK/LOCK not supported in TestRPC
 * Ignored in MetaMask
 */

function    doUnlockAccount()  {

    setData('lock_unlock_result','...',true);
    var account = document.getElementById('select_to_unlock_account').value;
    var password = document.getElementById('unlock_account_password').value;

    // synchronous flavor
    // web3.personal.unlockAccount(account, password, duration)
    // web3.personal.unlockAccount(account, password)
    

    web3.personal.unlockAccount(account, password,function(error, result)  {

        // console.log(error,result)
        if(error){
            setData('lock_unlock_result',error,true);
        } else {
            // Result = True if unlocked, else false
            var str = account.substring(0,20)+'...Unlocked';
            if(result){
                setData('lock_unlock_result',str,false);
            } else {
                // This does not get called - since and error is returned for incorrect password :-)
                str = 'Incorrect Password???';
                setData('lock_unlock_result',str,true);
            }
            
            
        }
    });
}

/**
 * Lock the account
 */
function    doLockAccount() {

    

    setData('lock_unlock_result','...',true);
    var account = document.getElementById('select_to_unlock_account').value;
    //Synchronous flavor
    //web3.personal.lockAccount(account)

    web3.personal.lockAccount(account, function(error, result){

        console.log(error,result)
        if(error){
            setData('lock_unlock_result',error,true);
        } else {
            var str = account.substring(0,20)+'...Locked';
            setData('lock_unlock_result',str,false);
        }
    });
}

/**
 * Gets the list of compilers
 */
function doGetCompilers()  {

    

    web3.eth.getCompilers(function(error, result){
        if(error){
            setData('list_of_compilers',error,true);
        } else {
            // result has an array of compilers
            if(result.length == 0)
                setData('list_of_compilers','No Compilers!!!',true);
            else
                setData('list_of_compilers',result,false);
        }
    });
}

/**
 * Starting geth 1.6 - Solidity compilation is not allowed from
 * web3 JSON/RPC
 */

function    doCompileSolidityContract()  {


    var source = document.getElementById('sourcecode').value;
  
    console.log(flattenSource(source));

    web3.eth.compile.solidity(source, function(error, result){

        if(error){
            console.log(error);
            setData('compilation_result',error,true);
        } else {
            // This is an issue seen only on windows - solc compile binary - ignore
            result = compileResultWindowsHack(result);
            console.log('Compilation Result=',JSON.stringify(result));
            var contract_1 = '';
            var code_1 = '';
            var abi_1 = '';
            for(var prop in result){
                contract_1 = prop;
                code_1 = result[prop].code;
                if(!code_1){
                    // Test RPC returns code in result.code
                    code_1 = result.code;
                }
                if(result[prop].info){
                    abi_1 = result[prop].info.abiDefinition;
                } else {
                    // Test RPC does not have the contracts :) in result
                    abi_1 = result.info.abiDefinition;
                }
                break;
            }
            // Populate the UI elements
            setData('compilation_result','Contract#1: '+contract_1,false);
            document.getElementById('compiled_bytecode').value=code_1;
            document.getElementById('compiled_abidefinition').value=JSON.stringify(abi_1);
            
        }
    });
}




/**
 * Deploys the contract - ASYNCH
 */

function    doDeployContract()   {
    // Reset the deployment results UI
    resetDeploymentResultUI();

    var     abiDefinitionString = document.getElementById('compiled_abidefinition').value;
    var     abiDefinition = JSON.parse(abiDefinitionString);

    var     bytecode = document.getElementById('compiled_bytecode').value;

    // 1. Create the contract object
    var  contract = web3.eth.contract(abiDefinition);

    // Get the estimated gas
    var   gas = document.getElementById('deployment_estimatedgas').value;

    // 2. Create the params for deployment - all other params are optional, uses default
    var  params = {
        // from: web3.eth.coinbase,
        from: web3.eth.accounts[0],
        data: bytecode,
        gas: gas
    }

    // 3. This is where the contract gets deployed
    // Callback method gets called *2* 
    // First time : Result = Txn Hash
    // Second time: Result = Contract Address
    var constructor_param = 10;

    contract.new(constructor_param,params,function(error,result){

        if(error){
            setData('contracttransactionhash','Deployment Failed: '+error,true);
        } else {
            console.log('RECV:',result)
            if(result.address){
                console.log('result', result);
                console.log('result.address', result.address);
                document.getElementById('contractaddress').value=result.address;
                setEtherscanIoLink('contractaddress_link','address',result.address);
            } else {
                // gets set in the first call
                setData('contracttransactionhash',result.transactionHash, false);
                setEtherscanIoLink('contracttransactionhash_link','tx',result.transactionHash);
            }
        }
    });
}

/**
 * Deploys the contract - Synchronous
 * Function not in use from UI. Created to show how once can use the synch API
 * contract.new
 */

function    doDeployContractSynchronous()   {

    var     abiDefinitionString = document.getElementById('compiled_abidefinition').value;
    var     abiDefinition = JSON.parse(abiDefinitionString);

    var     bytecode = document.getElementById('compiled_bytecode').value;

    // 1. Create the contract object
    var  contract = web3.eth.contract(abiDefinition);

    // Get the estimated gas
    var   gas = document.getElementById('deployment_estimatedgas').value;

    // 2. Create the params for deployment - all other params are optional, uses default
    var  params = {
        from: web3.eth.coinbase,
        data: bytecode,
        gas: gas
    }

    var contractData = contract.new.getData(10,{'data':bytecode});
    console.log('Contract Data=',contractData);
    // call send transaction and then call getTransactionReceipt
    params.data=contractData
    var transactionHash= web3.eth.sendTransaction(params)
    console.log('TxnHash=',transactionHash);
    web3.eth.getTransactionReceipt(transactionHash, function(error, result){
        if(error) console.log('SENDTran Error=', error)
        else   if(error) console.log('SENDTran Hash=', result);
    });

    return
}

// Utility method for creating the contract instance
function  createContractInstance(addr){
    var     abiDefinitionString = document.getElementById('compiled_abidefinition').value;
    var     abiDefinition = JSON.parse(abiDefinitionString);

    // Instance uses the definition to create the function

    var    contract = web3.eth.contract(abiDefinition);

   // THIS IS AN EXAMPLE - How to create a deploy using the contract
   // var instance = contract.new(constructor_params, {from:coinbase, gas:10000})
   // Use the next for manual deployment using the data generated
   // var contractData = contract.new.getData(constructor_params, {from:coinbase, gas:10000});

    var    address = addr;
    
    if(!address) address = document.getElementById('contractaddress').value;

    // Instance needs the address

    var    instance = contract.at(address);

    return instance;
}

/**
 * This invokes the contract function
 * locally on the node with no state change propagation
 */
function    doContractFunctionCall()  {
    // This leads to the invocation of the method locally
    var instance = createContractInstance();

    var    funcName = document.getElementById('contract_select_function').value;

    if(funcName === 'setNum'){
        var    parameterValue = document.getElementById('setnum_parameter').value;

        // MetaMask does not allow synchronous call to 'call' for non-constant function
        // Change this to asynchronous :)
        var value = instance.setNum.call(parameterValue);

        setExecuteResultUI('Call',funcName,parameterValue,value,'',false);
    } else {

        instance.getNum.call({},web3.eth.defaultBlock, function(error,result){
            setExecuteResultUI('Call',funcName,'',result,'',false);
        });

        
    }
}

/**
 * send Transaction costs Gas. State changes are recorded on the chain.
 */
function    doContractSendCall()   {
    // creating the cntract instance
    var instance = createContractInstance();
    // read the ui elements
    var estimatedGas = document.getElementById('contract_execute_estimatedgas').value;
    var parameterValue = document.getElementById('setnum_parameter').value;
    var funcName = document.getElementById('contract_select_function').value;
    //value NOT used as the contract function needs to be modified with "payable" modifier
    //var value = document.getElementById('invocation_send_value_in_ether').value;
    //value = web3.toWei(value,'ether');

    // Create the transaction object
    var    txnObject = {
        from: web3.eth.accounts[0],
        gas: estimatedGas
    }

    if(funcName === 'setNum'){
        // setNum with sendTransaction
        instance.setNum.sendTransaction(parameterValue,txnObject,function(error, result)  {

            console.log('RECVED>>',error,result);   
            if(error){
                setExecuteResultUI('Send Transaction:   ',funcName,'',error,'',true);
            } else {
                setExecuteResultUI('Send Transaction:   ',funcName,parameterValue,result,result,false);
            }
        });
    } else {
         // getNum with sendTransaction
        instance.getNum.sendTransaction(txnObject,function(error, result)  {

            console.log('RECVED>>',error,result);   
            if(error){
                setExecuteResultUI('Send Transaction:   ',funcName,'',error,'',true);
            } else {
                setExecuteResultUI('Send Transaction:   ',funcName,'',result,result,false);
            }
        });
    }        
}

/**
 * Starts the filter watch for events with options specified by the user
 */


function    doFilterWatchStart()   {
    //1. Stop the wtach if its already ON
    doFilterStopWatching();
    //2. Reset the UI
    setData('watch_event_count','0',false);

    //3. Create the filter option
    var options = generateFilterOptions();
    console.log('FILTER Watch Options:', JSON.stringify(options));

    //4. Set the applied watch filter UI Input box
    document.getElementById('applied_watch_filter').value=JSON.stringify(options);

    //5. Create instance of the filter
    filterWatch = web3.eth.filter(options);

    //6. Now start watching
    filterWatch.watch(function(error,result){
        if(error){
            console.error('Filter Watch Error: ',error);
        } else {
            filterEventCounter++;
            // Update the UI for the counter
            setData('watch_event_count', filterEventCounter, false);

            // Updates the UI with received event
            addEventListItem('watch_events_list',result,5);
        }
    });
}

/**
 * Stop watching for events
 */

function doFilterStopWatching()  {

    // 1. Stop watching if watching iactive
    if(filterWatch){
        filterWatch.stopWatching();
        filterWatch = undefined;
    }
    // 2. Reset the UI
    setData('watch_event_count','Not Watching',true);
    document.getElementById('applied_watch_filter').value='';

    // 3. Remove all of the past events from the list
    clearList('watch_events_list');

    // 4. reset the counter
    filterEventCounter = 0;
}

/**
 * Get the logs for the specified filter
 * Testnet sample contract address: 
 */

function    doFilterGetLogs()  {

    // 1. Clear the list
    clearList('get_logs_list');
    
    // 2. Create the filter option
    var options = generateFilterOptions();
    console.log('FILTER Get Options:', JSON.stringify(options));

    // 3. Set the applied watch filter UI Input box
    document.getElementById('applied_log_filter').value=JSON.stringify(options);

    // 4. Create the instance of the filter
    var filterGet = web3.eth.filter(options);

    // 5. Invoke get on filter with the callback function
    filterGet.get(function(error, result){
        if(error){
            console.log('GET Error:',error);
            setData('get_log_count',error, true);
        } else {
            // result = array of events
            // Update UI with the data received as an array of events
            setData('get_log_count',result.length, false);
            for(var i = 0; i < result.length ; i++){
                //console.log("Event.watch="+JSON.stringify(result[i]))
                addEventListItem('get_logs_list',result[i],50);
            }
        }
    });
}

/**
 * To start the event watching using the contract object
 */

function    doContractEventWatchStart() {

    if(contractEvent){
        doContractEventWatchStop();
    }

    // Reset the UI
    setData('watch_contract_instance_event_count','0',false);

    contractEvent = createContractEventInstance();

    contractEvent.watch(function(error, result){
        if(error){
            console.error('Contract Event Error');
        } else {
           
        //    console.log("Event.watch="+JSON.stringify(result))
            // increment the count watch_instance_event_count
            contractEventCounter++;
            setData('watch_contract_instance_event_count',contractEventCounter, false );

            addEventListItem('watch_contract_events_list',result,5);
        }
    });
}


/**
 * To stop the event watching using the contract object
 */

function doContractEventWatchStop()   {

    if(contractEvent){
        contractEvent.stopWatching();
        contractEvent = undefined;
    }
    contractEventCounter = 0;
    clearList('watch_contract_events_list');
    setData('watch_contract_instance_event_count', '---', true);
}

/**
 * Gets the logs for the specific contract instance
 */

function doContractEventGet() {

    clearList('get_contract_instance_logs_list');
    setData('get_contract_instance_log_count', '---', true);
    var event = createContractEventInstance();
    event.get(function(error, result){
        if(error){
            setData('get_contract_instance_log_count',error,true);
        } else {
            setData('get_contract_instance_log_count',result.length, false);
            for(var i = 0; i < result.length ; i++){
                addEventListItem('get_contract_instance_logs_list',result[i],50);
            }
        }
    });
}

/**
 * Utility method for creating an instance of the event
 */
function createContractEventInstance(){
    var contractAddress = document.getElementById('contract_instance_address').value

    var contractInstance = createContractInstance(contractAddress);

    // geth the indexed data values JSON
    var indexedEventValues = document.getElementById('indexed_event_values').value
    indexedEventValues = JSON.parse(indexedEventValues)

    var additionalFilterOptions = document.getElementById('additional_filter_event_values').value;
    additionalFilterOptions = JSON.parse(additionalFilterOptions);

    return contractInstance.NumberSetEvent(indexedEventValues, additionalFilterOptions);
}



/**
 * Contains utility functions for managing the UI
 */

// Holds the base URL for etherscan.io
var etherscanBaseUrl='https://ropsten.etherscan.io/';


// Since some of the functons/API are not available based on the
// Node type - this function disables certainelements
function    setUIBasedOnNodeType(){
    // Unlock Account - Check the node type
    
    if(nodeType === 'metamask' || nodeType == 'testrpc'){
        setData('lock_unlock_result','Unlock / lock ( ) not supported for '+nodeType,true);
    } else {
        setData('lock_unlock_result','--',false);
    }
    // Compiler options
    if(nodeType === 'geth' || nodeType === 'metamask'){
        // Not supported for geth & metamask
        setData('list_of_compilers','getCompilers ( ) & compileSolidity ( ) not supported for '+nodeType,true);

        // Disable the compile butto
        document.getElementById('button_do_compile').disabled = true;
        //document.getElementById("sourcecode").value="Compile sample contract in Remix | Wallet | solc . Copy & Paste the Bytecode | ABIDefinition for deployment.";
        document.getElementById('sourcecode').disabled=true;
    } else {
        setData('list_of_compilers','--',false);
        document.getElementById('button_do_compile').disabled = false;
        document.getElementById('sourcecode').disabled=false;   
    }

    // This simply creates the JSON for default transaction object
    generateTransactionJSON();
    copyBytecodeInterfaceToUI();
}

// Update the iframe data
function updateIFrameContent(iframe_id, data) {
    var iframe = document.getElementById(iframe_id);
    var iframedoc = iframe.contentDocument || iframe.contentWindow.document;
    iframedoc.body.innerHTML = html;
}

function setData(docElementId, html, errored) {
    document.getElementById(docElementId).innerHTML = html;
    if (errored) document.getElementById(docElementId).classList = 'notready';
    else document.getElementById(docElementId).classList = 'ready';
}

function arrayToMultilineString(arr) {
    var concat = '';
    for (var i = 0; i < arr.length; i++) {
        concat += arr[i] + '<br>'
    }
    return concat;
}

/**
 * Creates a list item for the account in the account list
 */
function addAccountsToList(listId,index,account){
    var li = document.createElement('LI');
    var input = document.createElement('INPUT')
    input.value = account;
    input.id = 'account'+index;
    input.disabled=true;
    li.appendChild(input)
    var list = document.getElementById(listId);
    list.appendChild(li)
}


/**
 * Creates a list item for the balance in the account balance list
 */
function addAccountBalancesToList(listId,index,accountBalance){
    var li = document.createElement('LI');
    li.class='ready'
    var input = document.createElement('P');
    input.class = 'ready';
    input.innerText=accountBalance+' Ether';
    li.appendChild(input);
    var list = document.getElementById(listId);
    list.appendChild(li)
}

/**
 * Removes all of the <li> in List
 */
function removeAllChildItems(elementId){
    var ele = document.getElementById(elementId);
    while (ele.hasChildNodes()) {   
        ele.removeChild(ele.firstChild);
    }
}

/**
 * This populates all <SELECT> boxes with accounts
 */
function    addAccountsToSelects(accounts){
    
    removeAllChildItems('send_from_account');
    removeAllChildItems('send_to_account');
    removeAllChildItems('select_to_unlock_account');
    for (var i = 0; i < accounts.length; i++) {
        addOptionToSelect('send_from_account', accounts[i].substring(0,15)+'...', accounts[i]);
        addOptionToSelect('send_to_account', accounts[i].substring(0,15)+'...', accounts[i]);
        addOptionToSelect('select_to_unlock_account', accounts[i].substring(0,15)+'...', accounts[i]);
    }
}

/**
 * Add options to a <select>
 */
function    addOptionToSelect(selectId, text, value){
    var option = document.createElement('OPTION');
    option.text = text;
    option.value = value;
    var select = document.getElementById(selectId);
    select.appendChild(option)

    // lets try data list add 
    // select = document.getElementById("browsers");
    // option = document.createElement('OPTION');
    // option.text=text
    // select.appendChild(option)
}

/**
 * This function creates the transaction object by reading the input elements
 */
function    createTransactionObjectJson(){
    var transObject = {};
    // get the from and to account 
    transObject.from = document.getElementById('send_from_account').value;
    transObject.to = document.getElementById('send_to_account_value').value;
    // Get the value in ether and convert to wie
    var valueInEther = document.getElementById('send_value_in_ether').value
    var valueInWei = web3.toWei(valueInEther,'ether');
    transObject.value = valueInWei;
    // set the gas and gasPrice
    if(document.getElementById('send_gas').value !== 'default')
        transObject.gas = document.getElementById('send_gas').value;
    if(document.getElementById('send_gas_price').value !== 'default')
        transObject.gasPrice = document.getElementById('send_gas_price').value;
    // set the data
    if(document.getElementById('send_data').value !== 'default'){
        // convert the ascii to hex
        var data = document.getElementById('send_data').value;
        transObject.data = web3.toHex(data);
    }
    // set the nonce
    if(document.getElementById('send_nonce').value !== 'default')
        transObject.nonce = document.getElementById('send_nonce').value;

    return transObject;
}

// The byte code for the 
function copyBytecodeInterfaceToUI(){
    document.getElementById('compiled_bytecode').value=(contract_bytecode);
    document.getElementById('compiled_abidefinition').value=(contract_abidefinition);
}

/**
 * Populates the JSON for transaction object
 */
function    generateTransactionJSON(){
    var tobject = createTransactionObjectJson();
    setData('send_transaction_object_json',JSON.stringify(tobject,undefined,2),false)
}

/**
 * Resets the value in the transaction object input values
 */
function    resetTransactionObjectParameters(){
    document.getElementById('send_gas').value = 'default';
    document.getElementById('send_gas_price').value = 'default';
    document.getElementById('send_data').value = 'default';
    document.getElementById('send_nonce').value = 'default';
    document.getElementById('send_value_in_ether').value = 0;
    generateTransactionJSON();
}

/**
 * Create the etherscan link
 */
function    createEtherscanIoUrl(type,hashOrNumber){

    // For TestRPC - this URL will have no meaning as the
    // Etherscan.io will not know about the Tx Hash

    var url = etherscanBaseUrl;
    if(type === 'tx'){
        url += 'tx/'+hashOrNumber;
    } else if(type === 'block'){
        url += 'block/'+hashOrNumber;
    } else if(type === 'address'){
        url += 'address/'+hashOrNumber;
    } 
    return url;
}

/**
 * Sets the href in the <a> tag for etherscan.io
 */
function   setEtherscanIoLink(aId, type, hashOrNumber){
    var etherscanLinkA=document.getElementById(aId);
    etherscanLinkA.href = createEtherscanIoUrl(type,hashOrNumber);
    if(hashOrNumber)
        etherscanLinkA.innerHTML='etherscan.io';
    else
        etherscanLinkA.innerHTML='';
}

/**
 * Flattens the source code for contract as it needs to be provided as a command line
 * argument to the solidity compiler
 */
function flattenSource(src){
    return src.replace(/\n/g, ' ');
}

/**
 * Windows Solidity Hack
 * On Windows for some reason the contracts in compiled result appear as "<stdin>:Contract" 
 * instead of just "Contract" so this hack simply removes the "<stdin>:" from the contract
 * names. No impact if the compilation result is in a good state.
 * */
function    compileResultWindowsHack(result){
    var cleaned = {}
    for(var prop in result){
        var newProp = prop.replace('<stdin>:','');
        cleaned[newProp] = result[prop];
    }
    return cleaned;
}

/**
 * Reset the deployment result UI
 */
function    resetDeploymentResultUI(){
    console.log('utils.resetDeploymentResultUI() TO BE CODED')
}

/**
 * Sets the Result UI components for the Execute call
 */
function    setExecuteResultUI(callType,functionName, parameter, return_value, txHash, error){
    var detail = callType+':'+functionName+'('+parameter+')';
    if(error)  detail += ' FAILED '+return_value;
    else detail += 'Successful';

    setData('invoke_details',detail,(error));

    setData('invoke_return_value',return_value,(error));

    console.log('return_value=',return_value)

    setData('invoke_contracttransactionhash', txHash, false);
    //invoke_contracttransactionhash_link
    setEtherscanIoLink('invoke_contracttransactionhash_link', 'tx', txHash);
}

/**
 * Generates the filter options array & updates the UI also
 */

function    generateFilterOptions()   {

    var options = {};
    var val = document.getElementById('from_block_filter').value;
    if(val && val.trim().length > 0)
                options['fromBlock'] = val;
    val = document.getElementById('to_block_filter').value;
    if(val && val.trim().length > 0)
                options['toBlock'] =  val;

    var val = document.getElementById('addresses_filter').value;
    // Addresses have multiple addresses separated by new line - need to be changed to comma separated
    val = val.trim();
    
    if(val.length > 0) {
        //val = val.replace('\n',',');
        val = val.split('\n');
        options['address'] = val;
    }
    val = document.getElementById('topics_filter').value;
    // only 3 topics allowed in options; array created with elements each in new line
    val = val.trim();

        console.log('SIG=',getHashEventSignature('NumberSetEvent(address,bytes32,bytes32)'))

    if(val.length > 0 ){
        val = val.split('\n');

        for(var i=0; i < val.length;i++){
            val[i] = val[i].trim()
            if(val[i] === 'null') val[i]=null;
        }
        options['topics'] = val;


    }



    setData('options_filter',JSON.stringify(options,undefined,2),false);
    return options;
}

/**
 * Adds a list element in the 0th position
 * Removes the last element if the length exceeds provided ln
 */
function    addEventListItem(listId, childData, len){
    
    console.log('Event:',childData);

    // check length
    var list = document.getElementById(listId);
    if(list.childNodes.length >= len){
        var i = list.childNodes.length - 1; // last child
        list.removeChild(list.childNodes[i]);
    }
    // Create the List Item for the events list
    var li = document.createElement('LI');

    // Add new event in the 0th position
    li.appendChild(createEventListItem(childData));
    list.insertBefore(li, list.childNodes[0]);
}

// Creates the item in the events list
function    createEventListItem(childData){
    var div = document.createElement('SPAN');
    var p = document.createElement('A');
    p.text = 'Log#'+childData.logIndex+', Txn#'+childData.transactionIndex;
    div.appendChild(p);
    var aLink = document.createElement('A')
    //Add block info link
    aLink.text = ', Blk#'+childData.blockNumber;
    aLink.href = createEtherscanIoUrl('block', childData.blockNumber);
    aLink.target='_blank';
    div.appendChild(aLink);
    // Add txn info link
    if(childData.transactionHash){
        aLink = document.createElement('A')
        aLink.text = ', Txn, ';
        aLink.href = createEtherscanIoUrl('tx', childData.transactionHash);
        aLink.target='_blank';
        div.appendChild(aLink);
    }
    // Address
    if(childData.address){
        aLink = document.createElement('A')
        aLink.text = 'Addr';
        aLink.href = createEtherscanIoUrl('address', childData.address);
        aLink.target='_blank';
        div.appendChild(aLink);
    }
    return div;
}

/**
 * Clears the items from a list element on the HTML page
 */
function    clearList(listId){
    var list = document.getElementById(listId);
    for(var i=list.childNodes.length-1; i>=0 ;i--){
        list.removeChild(list.childNodes[i]);
    }
}

/**
 * Adds the CONTRACT watch event to the list box 
 */
function    addContractEventListItem(listId, childData, len){
    console.log(JSON.stringify(childData))
}


/**
 * Hash signature of the event
 * Utility method to show how to generate the event signature
 * getHashEventSignature('NumberSetEvent(address,bytes32,bytes32)')
 */
function getHashEventSignature(evt){
    return web3.sha3(evt)
}